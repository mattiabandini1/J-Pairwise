package com.mattiabandini.jpairwise.io;

import com.mattiabandini.jpairwise.model.InputData;
import com.mattiabandini.jpairwise.model.Parameter;
import com.mattiabandini.jpairwise.model.TestCase;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Generates the Java source code for a JUnit 5 Parameterized Test.
 * <p>
 * This class takes the generated pairwise test cases and the input configuration
 * to produce a complete, compilable Java file. The generated test class uses
 * {@code @ParameterizedTest} and {@code @CsvSource} to execute the test combinations.
 * </p>
 */
public class JavaTestGenerator {

    /**
     * Generates the Java file containing the parameterized test.
     *
     * @param inputData The configuration data containing class names, package info, and method signatures.
     * @param testCases The list of pairwise test cases generated by the engine.
     * @throws IOException If an I/O error occurs while writing the file.
     */
    public void generateFile(InputData inputData, List<TestCase> testCases) throws IOException {

        List<Parameter> parameters = inputData.getParameters();
        String className = inputData.getClassName();
        String packageName = inputData.getPackageName();
        String targetClassName = inputData.getTargetClassName();
        String targetMethodName = inputData.getTargetMethodName();

        // Prepare the code segments
        String methodArgs = generateMethodSignature(parameters);
        String csvBody = generateCsvBody(parameters, testCases);
        String callArgs = generateMethodCallArgs(parameters);

        // Determine output path
        String packagePath = packageName.replace(".", "/");
        Path directory = Path.of("src", "test", "java", packagePath);

        // Ensure directory exists
        Files.createDirectories(directory);
        Path filePath = directory.resolve(className + ".java");

        // Construct the file content using a Text Block (Java 15+)
        String fileContent = """
                package %s;
                
                import org.junit.jupiter.api.Assertions;
                import org.junit.jupiter.params.ParameterizedTest;
                import org.junit.jupiter.params.provider.CsvSource;
                
                /**
                 * Auto-generated test class by J-Pairwise.
                 * Covers pairwise combinations for %s.%s.
                 */
                public class %s {
                
                    @ParameterizedTest
                    @CsvSource({
                        %s
                    })
                    void testGeneratedCombinations(%s) {
                        %s app = new %s();
                
                        var result = app.%s(%s);
                
                        var expected = getExpectedResult(%s);
                
                        Assertions.assertEquals(expected, result);
                    }
                
                    /**
                     * Placeholder for the oracle logic.
                     * You need to implement the logic to determine the expected result based on inputs.
                     */
                    private String getExpectedResult(%s) {
                        // TODO: Implement your verification logic here!
                        // Example:
                        // if (role.equals("Admin")) return "Success";
                        // return "Failure";
                
                        throw new UnsupportedOperationException("getExpectedResult() not implemented yet");
                    }
                }
                """.formatted(
                        packageName,
                        targetClassName, targetMethodName,
                        className,
                        csvBody,
                        methodArgs,
                        targetClassName, targetClassName,
                        targetMethodName, callArgs,
                        callArgs,
                        methodArgs);

        Files.writeString(filePath, fileContent, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
        System.out.println("File generated: " + filePath.toAbsolutePath());
    }

    /**
     * Generates the method signature string for the test method.
     * E.g., "String browser, String os"
     */
    private String generateMethodSignature(List<Parameter> parameters) {
        return parameters.stream()
                .map(p -> "String " + p.name().toLowerCase())
                .collect(Collectors.joining(", "));
    }

    /**
     * Generates the CSV body for the @CsvSource annotation.
     * E.g., "Chrome,Windows",
     *       "Firefox,Linux"
     */
    private String generateCsvBody(List<Parameter> parameters, List<TestCase> testCases) {
        StringBuilder sb =  new StringBuilder();
        for (int i = 0; i < testCases.size(); i++) {
            TestCase tc = testCases.get(i);
            List<String> orderedValues = new ArrayList<>();

            for (Parameter p : parameters) {
                String val = tc.get(p.name());
                orderedValues.add(val);
            }

            String rowContent = String.join(",", orderedValues);
            sb.append('"').append(rowContent).append('"');

            if (i < testCases.size() - 1) {
                sb.append(",\n\t\t");
            }
        }
        return sb.toString();
    }

    /**
     * Generates the arguments string for calling the method under test.
     * E.g., "browser, os"
     */
    private String generateMethodCallArgs(List<Parameter> parameters) {
        return parameters.stream()
                .map(p -> p.name().toLowerCase())
                .collect(Collectors.joining(", "));
    }
}
